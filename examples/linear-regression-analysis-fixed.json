{
  "cells": [
    {
      "type": "markdown",
      "id": "md_01",
      "content": "# Statistical Analysis: Linear Regression with Plotly\n\nThis notebook demonstrates statistical analysis using linear regression with interactive Plotly visualizations. We'll generate synthetic data, perform regression analysis, and create beautiful interactive plots.\n\n## Overview\n1. **Data Generation**: Create synthetic dataset with linear relationship\n2. **Linear Regression**: Fit regression model and analyze results\n3. **Interactive Visualization**: Use Plotly for dynamic charts\n4. **Model Evaluation**: Calculate performance metrics\n5. **Advanced Analysis**: Residual plots and confidence intervals"
    },
    {
      "type": "code",
      "id": "code_01",
      "code": "// Import required libraries (tf is injected globally, others need require)\nconst d3 = require('d3');\nconst Plotly = require('plotly.js-dist-min');\n\nconsole.log('TensorFlow.js version:', tf.version.tfjs);\nconsole.log('Libraries loaded successfully');\n\n// Generate synthetic data with linear relationship + noise\nconst n_samples = 100;\nconst noise_level = 2.0;\n\n// True relationship: y = 2.5 * x + 1.0 + noise\nconst data = d3.range(n_samples).map(() => {\n    const x = Math.random() * 10; // Random x between 0-10\n    const noise = d3.randomNormal(0, noise_level)(); // Normal distributed noise\n    const y = 2.5 * x + 1.0 + noise;\n    return { x, y };\n});\n\n// Extract x and y arrays using D3\nconst x_data = data.map(d => d.x);\nconst y_data = data.map(d => d.y);\n\n// Data statistics using D3\nconst x_extent = d3.extent(x_data);\nconst y_extent = d3.extent(y_data);\nconst x_mean = d3.mean(x_data);\nconst y_mean = d3.mean(y_data);\n\nconsole.log(`Generated ${n_samples} data points`);\nconsole.log(`X range: ${x_extent[0].toFixed(2)} to ${x_extent[1].toFixed(2)} (mean: ${x_mean.toFixed(2)})`);\nconsole.log(`Y range: ${y_extent[0].toFixed(2)} to ${y_extent[1].toFixed(2)} (mean: ${y_mean.toFixed(2)})`);\n\n// Export data for use in other cells\nexports.x_data = x_data;\nexports.y_data = y_data;\nexports.n_samples = n_samples;\nexports.data = data;"
    },
    {
      "type": "markdown",
      "id": "md_02",
      "content": "## Data Generation Results\n\nWe've generated **{{n_samples}}** synthetic data points using **D3.js** following the relationship:\n\n**y = 2.5x + 1.0 + noise**\n\nThe data ranges:\n- **X values**: {{d3.extent(x_data)[0].toFixed(2)}} to {{d3.extent(x_data)[1].toFixed(2)}} (mean: {{d3.mean(x_data).toFixed(2)}})\n- **Y values**: {{d3.extent(y_data)[0].toFixed(2)}} to {{d3.extent(y_data)[1].toFixed(2)}} (mean: {{d3.mean(y_data).toFixed(2)}})\n\nThis simulates a real-world scenario where we have a linear relationship with normally distributed noise using D3's `d3.randomNormal()` function."
    },
    {
      "type": "code",
      "id": "code_02",
      "code": "// Perform linear regression using TensorFlow.js\nconsole.log('Building TensorFlow.js regression model...');\n\n// Normalize the data to prevent numerical issues\nconst x_min = Math.min(...x_data);\nconst x_max = Math.max(...x_data);\nconst y_min = Math.min(...y_data);\nconst y_max = Math.max(...y_data);\n\nconsole.log(`Data ranges - X: [${x_min.toFixed(2)}, ${x_max.toFixed(2)}], Y: [${y_min.toFixed(2)}, ${y_max.toFixed(2)}]`);\n\nconst x_normalized = x_data.map(x => (x - x_min) / (x_max - x_min));\nconst y_normalized = y_data.map(y => (y - y_min) / (y_max - y_min));\n\n// Convert normalized data to tensors\nconst xs = tf.tensor2d(x_normalized.map(x => [x]));\nconst ys = tf.tensor1d(y_normalized);\n\n// Create a simple linear model (Dense layer with 1 unit)\nconst model = tf.sequential({\n    layers: [\n        tf.layers.dense({\n            inputShape: [1],\n            units: 1,\n            useBias: true,\n            kernelInitializer: 'randomNormal',\n            biasInitializer: 'zeros'\n        })\n    ]\n});\n\n// Compile the model with Adam optimizer and smaller learning rate\nmodel.compile({\n    optimizer: tf.train.adam(0.01), // Much smaller learning rate\n    loss: 'meanSquaredError',\n    metrics: ['mae']\n});\n\n// Train the model\nconsole.log('Training model...');\nconst history = await model.fit(xs, ys, {\n    epochs: 200,\n    verbose: 0,\n    callbacks: {\n        onEpochEnd: (epoch, logs) => {\n            if (epoch % 40 === 0) {\n                console.log(`Epoch ${epoch}: loss = ${logs.loss.toFixed(6)}`);\n            }\n        }\n    }\n});\n\n// Get model weights (slope and intercept) in normalized space\nconst weights = model.getWeights();\nconst slope_norm = await weights[0].data();\nconst intercept_norm = await weights[1].data();\n\n// Convert normalized weights back to original scale\nconst slope = slope_norm[0] * (y_max - y_min) / (x_max - x_min);\nconst intercept = intercept_norm[0] * (y_max - y_min) + y_min - slope * x_min;\n\nconsole.log('Model training completed!');\nconsole.log(`Normalized slope: ${slope_norm[0].toFixed(4)}, intercept: ${intercept_norm[0].toFixed(4)}`);\nconsole.log(`Original scale - Slope: ${slope.toFixed(4)}, Intercept: ${intercept.toFixed(4)}`);\n\n// Make predictions on normalized data, then convert back\nconst predictions_norm = model.predict(xs);\nconst y_pred_norm = await predictions_norm.data();\nconst y_pred = Array.from(y_pred_norm).map(y => y * (y_max - y_min) + y_min);\n\n// Calculate R-squared manually\nconst y_mean = d3.mean(y_data);\nconst ss_tot = d3.sum(y_data.map(y => (y - y_mean) ** 2));\nconst ss_res = d3.sum(y_data.map((y, i) => (y - y_pred[i]) ** 2));\nconst r2 = 1 - (ss_res / ss_tot);\n\n// Calculate other metrics\nconst residuals = y_data.map((y, i) => y - y_pred[i]);\nconst mse = d3.mean(residuals.map(r => r * r));\nconst rmse = Math.sqrt(mse);\nconst mae = d3.mean(residuals.map(r => Math.abs(r)));\n\nconsole.log('=== TensorFlow.js Linear Regression Results ===');\nconsole.log(`Slope: ${slope.toFixed(4)}`);\nconsole.log(`Intercept: ${intercept.toFixed(4)}`);\nconsole.log(`R-squared: ${r2.toFixed(4)}`);\nconsole.log(`RMSE: ${rmse.toFixed(4)}`);\nconsole.log(`MAE: ${mae.toFixed(4)}`);\nconsole.log(`Final loss: ${history.history.loss[history.history.loss.length - 1].toFixed(6)}`);\n\n// Clean up tensors\nxs.dispose();\nys.dispose();\npredictions_norm.dispose();\n\n// Export results\nexports.slope = slope;\nexports.intercept = intercept;\nexports.r2 = r2;\nexports.y_pred = y_pred;\nexports.residuals = residuals;\nexports.mse = mse;\nexports.rmse = rmse;\nexports.mae = mae;\nexports.model = model;\nexports.training_history = history.history;\nexports.regression_equation = `y = ${slope.toFixed(2)}x + ${intercept.toFixed(2)}`;\nexports.x_min = x_min;\nexports.x_max = x_max;\nexports.y_min = y_min;\nexports.y_max = y_max;"
    },
    {
      "type": "markdown",
      "id": "md_03",
      "content": "## TensorFlow.js Regression Results\n\nOur **TensorFlow.js neural network** has successfully fitted the data:\n\n### Model Architecture\n- **Type**: Sequential model with single Dense layer\n- **Optimizer**: Adam with learning rate 0.01\n- **Loss Function**: Mean Squared Error\n- **Training**: 200 epochs with data normalization\n\n### Model Equation\n**{{regression_equation}}**\n\n### Performance Metrics\n- **R-squared**: {{r2.toFixed(4)}} ({{(r2 * 100).toFixed(1)}}% of variance explained)\n- **RMSE**: {{rmse.toFixed(4)}}\n- **MAE**: {{mae.toFixed(4)}}\n- **Final Training Loss**: {{training_history.loss[training_history.loss.length - 1].toFixed(6)}}\n\n### Model Interpretation\n- **Slope (Weight)**: {{slope.toFixed(4)}} - For each unit increase in X, Y increases by {{slope.toFixed(2)}} units\n- **Intercept (Bias)**: {{intercept.toFixed(4)}} - The predicted Y value when X = 0\n- **R-squared**: {{(r2 * 100).toFixed(1)}}% - The model explains {{(r2 * 100).toFixed(1)}}% of the variance\n\nThe TensorFlow.js model successfully recovered our true relationship (y = 2.5x + 1.0) through gradient descent optimization!"
    },
    {
      "type": "code",
      "id": "code_03",
      "code": "// Create interactive scatter plot with regression line using Plotly\nconst plotContainer = document.createElement('div');\nplotContainer.style.width = '100%';\nplotContainer.style.height = '500px';\n\n// Prepare data traces\nconst scatterTrace = {\n    x: x_data,\n    y: y_data,\n    mode: 'markers',\n    type: 'scatter',\n    name: 'Data Points',\n    marker: {\n        color: 'rgba(67, 156, 255, 0.7)',\n        size: 8,\n        line: {\n            color: 'rgba(67, 156, 255, 1)',\n            width: 1\n        }\n    },\n    hovertemplate: 'X: %{x:.2f}<br>Y: %{y:.2f}<extra></extra>'\n};\n\n// Create regression line\nconst x_line = [Math.min(...x_data), Math.max(...x_data)];\nconst y_line = x_line.map(x => slope * x + intercept);\n\nconst regressionTrace = {\n    x: x_line,\n    y: y_line,\n    mode: 'lines',\n    type: 'scatter',\n    name: `Regression Line (R² = ${r2.toFixed(3)})`,\n    line: {\n        color: 'rgba(255, 99, 71, 1)',\n        width: 3\n    },\n    hovertemplate: 'Regression Line<br>X: %{x:.2f}<br>Y: %{y:.2f}<extra></extra>'\n};\n\n// Layout configuration\nconst layout = {\n    title: {\n        text: 'Linear Regression Analysis',\n        font: { size: 20, color: '#ffffff' }\n    },\n    xaxis: {\n        title: 'X Variable',\n        gridcolor: 'rgba(255,255,255,0.1)',\n        color: '#ffffff'\n    },\n    yaxis: {\n        title: 'Y Variable', \n        gridcolor: 'rgba(255,255,255,0.1)',\n        color: '#ffffff'\n    },\n    plot_bgcolor: 'rgba(0,0,0,0)',\n    paper_bgcolor: 'rgba(0,0,0,0)',\n    font: { color: '#ffffff' },\n    legend: {\n        x: 0.02,\n        y: 0.98,\n        bgcolor: 'rgba(0,0,0,0.5)',\n        bordercolor: 'rgba(255,255,255,0.2)',\n        borderwidth: 1\n    },\n    hovermode: 'closest'\n};\n\n// Plot configuration\nconst config = {\n    responsive: true,\n    displayModeBar: true,\n    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],\n    displaylogo: false\n};\n\n// Create the plot\nPlotly.newPlot(plotContainer, [scatterTrace, regressionTrace], layout, config);\n\nconsole.log('Created interactive scatter plot with regression line');\nplotContainer;"
    },
    {
      "type": "code",
      "id": "code_04",
      "code": "// Create residual analysis plots using D3 for calculations\nconst residualContainer = document.createElement('div');\nresidualContainer.style.width = '100%';\nresidualContainer.style.height = '400px';\n\n// Plot configuration\nconst config = {\n    responsive: true,\n    displayModeBar: true,\n    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],\n    displaylogo: false\n};\n\n// Use D3 to calculate residual statistics\nconst residual_stats = {\n    mean: d3.mean(residuals),\n    median: d3.median(residuals),\n    std: Math.sqrt(d3.variance(residuals)),\n    min: d3.min(residuals),\n    max: d3.max(residuals),\n    q1: d3.quantile(residuals.sort(d3.ascending), 0.25),\n    q3: d3.quantile(residuals.sort(d3.ascending), 0.75)\n};\n\n// Residuals vs Fitted values plot\nconst residualTrace = {\n    x: y_pred,\n    y: residuals,\n    mode: 'markers',\n    type: 'scatter',\n    name: 'Residuals',\n    marker: {\n        color: 'rgba(255, 193, 7, 0.7)',\n        size: 8,\n        line: {\n            color: 'rgba(255, 193, 7, 1)',\n            width: 1\n        }\n    },\n    hovertemplate: 'Fitted: %{x:.2f}<br>Residual: %{y:.2f}<extra></extra>'\n};\n\n// Add horizontal line at y=0\nconst zeroLine = {\n    x: d3.extent(y_pred),\n    y: [0, 0],\n    mode: 'lines',\n    type: 'scatter',\n    name: 'Zero Line',\n    line: {\n        color: 'rgba(255, 255, 255, 0.5)',\n        width: 2,\n        dash: 'dash'\n    },\n    showlegend: false,\n    hoverinfo: 'skip'\n};\n\n// Add confidence bands (±2 standard deviations)\nconst upper_band = {\n    x: d3.extent(y_pred),\n    y: [2 * residual_stats.std, 2 * residual_stats.std],\n    mode: 'lines',\n    type: 'scatter',\n    name: '+2σ',\n    line: { color: 'rgba(255, 99, 71, 0.3)', width: 1, dash: 'dot' },\n    showlegend: false,\n    hoverinfo: 'skip'\n};\n\nconst lower_band = {\n    x: d3.extent(y_pred),\n    y: [-2 * residual_stats.std, -2 * residual_stats.std],\n    mode: 'lines',\n    type: 'scatter',\n    name: '-2σ',\n    line: { color: 'rgba(255, 99, 71, 0.3)', width: 1, dash: 'dot' },\n    showlegend: false,\n    hoverinfo: 'skip'\n};\n\nconst residualLayout = {\n    title: {\n        text: 'Residual Analysis (D3 Statistics)',\n        font: { size: 18, color: '#ffffff' }\n    },\n    xaxis: {\n        title: 'Fitted Values',\n        gridcolor: 'rgba(255,255,255,0.1)',\n        color: '#ffffff'\n    },\n    yaxis: {\n        title: 'Residuals',\n        gridcolor: 'rgba(255,255,255,0.1)', \n        color: '#ffffff'\n    },\n    plot_bgcolor: 'rgba(0,0,0,0)',\n    paper_bgcolor: 'rgba(0,0,0,0)',\n    font: { color: '#ffffff' },\n    hovermode: 'closest',\n    annotations: [{\n        x: 0.02, y: 0.98, xref: 'paper', yref: 'paper',\n        text: `Mean: ${residual_stats.mean.toFixed(4)}<br>Std: ${residual_stats.std.toFixed(3)}`,\n        showarrow: false,\n        font: { color: '#ffffff', size: 10 },\n        bgcolor: 'rgba(0,0,0,0.5)',\n        bordercolor: 'rgba(255,255,255,0.2)',\n        borderwidth: 1\n    }]\n};\n\nPlotly.newPlot(residualContainer, [residualTrace, zeroLine, upper_band, lower_band], residualLayout, config);\n\nconsole.log('=== D3-Calculated Residual Statistics ===');\nconsole.log(`Mean: ${residual_stats.mean.toFixed(6)} (should be ~0)`);\nconsole.log(`Median: ${residual_stats.median.toFixed(4)}`);\nconsole.log(`Standard deviation: ${residual_stats.std.toFixed(4)}`);\nconsole.log(`Min: ${residual_stats.min.toFixed(4)}, Max: ${residual_stats.max.toFixed(4)}`);\nconsole.log(`Interquartile range: [${residual_stats.q1.toFixed(3)}, ${residual_stats.q3.toFixed(3)}]`);\n\nexports.residual_stats = residual_stats;\n\nresidualContainer;"
    },
    {
      "type": "code",
      "id": "code_05",
      "code": "// Training Loss Visualization with Plotly\nconst lossContainer = document.createElement('div');\nlossContainer.style.width = '100%';\nlossContainer.style.height = '400px';\n\n// Plot configuration\nconst config = {\n    responsive: true,\n    displayModeBar: true,\n    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],\n    displaylogo: false\n};\n\n// Prepare training loss data\nconst epochs = training_history.loss.map((_, i) => i);\nconst lossValues = training_history.loss;\n\nconst lossTrace = {\n    x: epochs,\n    y: lossValues,\n    mode: 'lines',\n    type: 'scatter',\n    name: 'Training Loss',\n    line: {\n        color: 'rgba(255, 99, 132, 1)',\n        width: 3\n    },\n    hovertemplate: 'Epoch: %{x}<br>Loss: %{y:.6f}<extra></extra>'\n};\n\n// Add smoothed trend line using D3\nconst windowSize = 10;\nconst smoothedLoss = [];\nfor (let i = 0; i < lossValues.length; i++) {\n    const start = Math.max(0, i - windowSize + 1);\n    const end = i + 1;\n    const window = lossValues.slice(start, end);\n    smoothedLoss.push(d3.mean(window));\n}\n\nconst trendTrace = {\n    x: epochs,\n    y: smoothedLoss,\n    mode: 'lines',\n    type: 'scatter',\n    name: `Smoothed Trend (${windowSize}-epoch window)`,\n    line: {\n        color: 'rgba(54, 162, 235, 0.8)',\n        width: 2,\n        dash: 'dash'\n    },\n    hovertemplate: 'Epoch: %{x}<br>Smoothed Loss: %{y:.6f}<extra></extra>'\n};\n\nconst lossLayout = {\n    title: {\n        text: 'TensorFlow.js Training Loss Over Time',\n        font: { size: 18, color: '#ffffff' }\n    },\n    xaxis: {\n        title: 'Epoch',\n        gridcolor: 'rgba(255,255,255,0.1)',\n        color: '#ffffff'\n    },\n    yaxis: {\n        title: 'Mean Squared Error Loss',\n        type: 'log',\n        gridcolor: 'rgba(255,255,255,0.1)',\n        color: '#ffffff'\n    },\n    plot_bgcolor: 'rgba(0,0,0,0)',\n    paper_bgcolor: 'rgba(0,0,0,0)',\n    font: { color: '#ffffff' },\n    legend: {\n        x: 0.7,\n        y: 0.95,\n        bgcolor: 'rgba(0,0,0,0.5)',\n        bordercolor: 'rgba(255,255,255,0.2)',\n        borderwidth: 1\n    },\n    annotations: [{\n        x: epochs[epochs.length - 1],\n        y: lossValues[lossValues.length - 1],\n        text: `Final: ${lossValues[lossValues.length - 1].toFixed(6)}`,\n        showarrow: true,\n        arrowhead: 2,\n        arrowcolor: '#ffffff',\n        font: { color: '#ffffff', size: 10 },\n        bgcolor: 'rgba(255, 99, 132, 0.8)',\n        bordercolor: '#ffffff',\n        borderwidth: 1\n    }]\n};\n\nPlotly.newPlot(lossContainer, [lossTrace, trendTrace], lossLayout, config);\n\nconsole.log(`Created training loss plot - converged from ${lossValues[0].toFixed(6)} to ${lossValues[lossValues.length-1].toFixed(6)}`);\n\nlossContainer;"
    },
    {
      "type": "markdown",
      "id": "md_04",
      "content": "## Interactive Plotly Visualizations\n\n### Training Loss Analysis\nThe loss curve shows how TensorFlow.js optimized the model:\n- **Convergence**: Loss decreased from initial high values to final optimum\n- **Stability**: Adam optimizer provided smooth convergence\n- **Log Scale**: Shows convergence pattern more clearly\n- **Smoothed Trend**: D3-calculated moving average reveals optimization pattern\n\n### Residual Analysis with D3 Statistics\nValidates our regression assumptions:\n- **Mean**: {{residual_stats.mean.toFixed(6)}} (very close to 0 ✓)\n- **Standard Deviation**: {{residual_stats.std.toFixed(4)}}\n- **Random Scatter**: Confirms linear relationship assumption\n- **Homoscedasticity**: Constant variance across fitted values\n\n### Model Performance Summary\n- **R-squared**: {{(r2 * 100).toFixed(1)}}% variance explained\n- **Equation**: {{regression_equation}}\n- **Quality**: {{r2 > 0.9 ? 'Excellent' : r2 > 0.7 ? 'Good' : 'Moderate'}} model fit\n- **Libraries**: TensorFlow.js + D3.js + Plotly.js ecosystem\n\n### Key Insights\n1. **Data Normalization**: Essential for numerical stability in TensorFlow.js\n2. **Adam Optimizer**: Superior convergence compared to basic SGD\n3. **Interactive Visualization**: Plotly provides publication-quality charts\n4. **Statistical Validation**: D3 enables comprehensive residual analysis\n5. **Browser-Native ML**: Complete data science workflow without external dependencies\n\nThis demonstrates the power and maturity of the **JavaScript machine learning ecosystem** for serious statistical analysis!"
    }
  ]
}
