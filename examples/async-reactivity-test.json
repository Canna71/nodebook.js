{
  "cells": [
    {
      "id": "md_01",
      "type": "markdown",
      "content": "# Async Reactivity Test\n\n## Purpose\nThis notebook tests that async/await operations properly maintain reactivity in NotebookJS. We'll create a chain of dependencies where:\n\n1. **Input Cell**: Slider that changes a parameter\n2. **Async Code Cell**: Performs async calculation based on slider value\n3. **Dependent Code Cell**: Uses async result for further calculations\n4. **Display Cell**: Shows final results\n\n## What to Test\n- ✅ Slider changes trigger async code re-execution\n- ✅ Async code completion triggers dependent cell execution\n- ✅ All updates happen in correct order\n- ✅ No race conditions or lost updates\n- ✅ Error handling works in reactive async chain\n- ✅ UI updates reflect all changes properly"
    },
    {
      "id": "var_01",
      "type": "input",
      "variableName": "asyncDelay",
      "inputType": "range",
      "value": 500,
      "min": 100,
      "max": 2000,
      "step": 100,
      "label": "Async Delay (ms)"
    },
    {
      "id": "var_02", 
      "type": "input",
      "variableName": "multiplier",
      "inputType": "range",
      "value": 2,
      "min": 1,
      "max": 10,
      "step": 0.5,
      "label": "Calculation Multiplier"
    },
    {
      "id": "code_01",
      "type": "code",
      "code": "// ASYNC CODE CELL: Simulates async computation based on input values\n// This should re-execute whenever asyncDelay or multiplier changes\n\nconst cellStartTime = Date.now();\nconsole.log(`🔄 Starting async calculation with delay: ${asyncDelay}ms, multiplier: ${multiplier}`);\nconsole.log(`🕐 Cell start time: ${new Date(cellStartTime).toLocaleTimeString()}`);\n\n// Simulate async computation (e.g., API call, ML training, data processing)\nasync function performAsyncCalculation(delay, mult) {\n    const asyncStartTime = Date.now();\n    console.log(`⏳ Async operation starting (${delay}ms delay)... at ${new Date(asyncStartTime).toLocaleTimeString()}`);\n    \n    // Simulate variable processing time\n    await new Promise(resolve => setTimeout(resolve, delay));\n    \n    const asyncEndTime = Date.now();\n    const actualDelay = asyncEndTime - asyncStartTime;\n    \n    // Simulate some computation\n    const result = {\n        baseValue: Math.random() * 100,\n        multipliedValue: 0,\n        requestedDelay: delay,\n        actualDelay: actualDelay,\n        cellStartTime: cellStartTime,\n        asyncStartTime: asyncStartTime,\n        asyncEndTime: asyncEndTime,\n        inputs: { asyncDelay: delay, multiplier: mult } // Store input values used\n    };\n    \n    // Apply multiplier\n    result.multipliedValue = result.baseValue * mult;\n    \n    console.log(`✅ Async calculation completed in ${actualDelay}ms (requested: ${delay}ms)`);\n    console.log(`📊 Result: ${result.baseValue.toFixed(2)} × ${mult} = ${result.multipliedValue.toFixed(2)}`);\n    \n    return result;\n}\n\n// Perform the async calculation\nconst asyncResult = await performAsyncCalculation(asyncDelay, multiplier);\n\n// Export for dependent cells with better timing info\nexports.asyncResult = asyncResult;\nexports.asyncCellCompletedAt = Date.now();\n\nconsole.log(`🎯 Async cell completed at ${new Date(Date.now()).toLocaleTimeString()}. Result exported for dependent cells.`);"
    },
    {
      "id": "code_02",
      "type": "code", 
      "code": "// DEPENDENT CODE CELL: Uses async result for further calculations\n// This should re-execute whenever asyncResult changes (i.e., when async calculation completes)\n\nconst dependentStartTime = Date.now();\nconsole.log(`🔗 Dependent calculation triggered at ${new Date(dependentStartTime).toLocaleTimeString()}`);\nconsole.log(`📥 Using async result from ${new Date(asyncResult.asyncEndTime).toLocaleTimeString()}`);\nconsole.log(`🔍 Async used inputs: delay=${asyncResult.inputs.asyncDelay}ms, multiplier=${asyncResult.inputs.multiplier}`);\n\n// Verify we're using current input values\nconst inputsMatch = {\n    delayMatches: asyncResult.inputs.asyncDelay === asyncDelay,\n    multiplierMatches: asyncResult.inputs.multiplier === multiplier\n};\n\nconsole.log(`✅ Input consistency: delay ${inputsMatch.delayMatches ? 'MATCH' : 'MISMATCH'}, multiplier ${inputsMatch.multiplierMatches ? 'MATCH' : 'MISMATCH'}`);\n\n// Perform additional calculations based on async result\nconst dependentCalculations = {\n    // Statistical calculations\n    doubled: asyncResult.multipliedValue * 2,\n    squared: Math.pow(asyncResult.multipliedValue, 2),\n    sqrt: Math.sqrt(Math.abs(asyncResult.multipliedValue)),\n    \n    // Conditional logic\n    category: asyncResult.multipliedValue > 100 ? 'High' : \n              asyncResult.multipliedValue > 50 ? 'Medium' : 'Low',\n    \n    // Time-based calculations (fixed)\n    asyncToDependent: dependentStartTime - asyncResult.asyncEndTime,\n    totalFromCellStart: dependentStartTime - asyncResult.cellStartTime,\n    asyncActualDelay: asyncResult.actualDelay,\n    \n    // Derived metrics\n    efficiency: asyncResult.multipliedValue / asyncResult.actualDelay * 1000, // per second\n    \n    // Chain metadata\n    chainStep: 'dependent',\n    dependsOn: 'asyncResult',\n    completedAt: Date.now(),\n    inputConsistency: inputsMatch\n};\n\nconsole.log(`📈 Dependent calculations:`);\nconsole.log(`   - Doubled: ${dependentCalculations.doubled.toFixed(2)}`);\nconsole.log(`   - Squared: ${dependentCalculations.squared.toFixed(2)}`);\nconsole.log(`   - Category: ${dependentCalculations.category}`);\nconsole.log(`   - Efficiency: ${dependentCalculations.efficiency.toFixed(2)} units/sec`);\nconsole.log(`   - Async→Dependent delay: ${dependentCalculations.asyncToDependent}ms`);\nconsole.log(`   - Total processing: ${dependentCalculations.totalFromCellStart}ms`);\n\n// Export for final display\nexports.dependentCalculations = dependentCalculations;\nexports.chainCompleted = true;\n\nconsole.log(`✅ Dependent cell completed. Chain step 2/3 done.`);"
    },
    {
      "id": "code_03",
      "type": "code",
      "code": "// FINAL DISPLAY CELL: Creates summary and visualizations\n// This should re-execute when dependentCalculations changes\n\nconst displayStartTime = Date.now();\nconsole.log(`📊 Creating final display at ${new Date(displayStartTime).toLocaleTimeString()}. Chain completed: ${chainCompleted}`);\n\n// Create comprehensive summary with corrected timing\nconst summary = {\n    // Current input parameters (what sliders show now)\n    currentInputs: {\n        asyncDelay: asyncDelay,\n        multiplier: multiplier\n    },\n    \n    // Input parameters used by async calculation\n    asyncUsedInputs: {\n        asyncDelay: asyncResult.inputs.asyncDelay,\n        multiplier: asyncResult.inputs.multiplier\n    },\n    \n    // Input consistency check\n    inputConsistency: {\n        delayConsistent: asyncDelay === asyncResult.inputs.asyncDelay,\n        multiplierConsistent: multiplier === asyncResult.inputs.multiplier,\n        overallConsistent: false\n    },\n    \n    // Async result summary\n    asyncComputation: {\n        baseValue: asyncResult.baseValue.toFixed(2),\n        multipliedValue: asyncResult.multipliedValue.toFixed(2),\n        requestedDelay: asyncResult.requestedDelay,\n        actualDelay: asyncResult.actualDelay\n    },\n    \n    // Dependent calculations summary\n    derivedValues: {\n        doubled: dependentCalculations.doubled.toFixed(2),\n        squared: dependentCalculations.squared.toFixed(0),\n        category: dependentCalculations.category,\n        efficiency: dependentCalculations.efficiency.toFixed(2)\n    },\n    \n    // Corrected timing analysis\n    performance: {\n        asyncDelay: asyncResult.actualDelay,\n        asyncToDependent: dependentCalculations.asyncToDependent,\n        totalProcessing: dependentCalculations.totalFromCellStart,\n        efficiency: `${dependentCalculations.efficiency.toFixed(1)} units/sec`\n    }\n};\n\n// Set overall consistency\nsummary.inputConsistency.overallConsistent = \n    summary.inputConsistency.delayConsistent && \n    summary.inputConsistency.multiplierConsistent;\n\n// Reactivity validation\nconst reactivityTest = {\n    currentInputs: `${asyncDelay}ms delay, ${multiplier}x multiplier`,\n    asyncUsedInputs: `${asyncResult.inputs.asyncDelay}ms delay, ${asyncResult.inputs.multiplier}x multiplier`,\n    inputsConsistent: summary.inputConsistency.overallConsistent,\n    asyncTriggered: asyncResult.asyncEndTime > 0,\n    dependentTriggered: dependentCalculations.completedAt > asyncResult.asyncEndTime,\n    chainIntact: chainCompleted === true,\n    allStepsCompleted: true\n};\n\n// Create visual summary\nconsole.log(`\\n🎯 === ASYNC REACTIVITY TEST SUMMARY ===`);\nconsole.log(`📥 Current inputs: ${summary.currentInputs.asyncDelay}ms delay, ${summary.currentInputs.multiplier}x multiplier`);\nconsole.log(`🔍 Async used inputs: ${summary.asyncUsedInputs.asyncDelay}ms delay, ${summary.asyncUsedInputs.multiplier}x multiplier`);\nconsole.log(`✅ Input consistency: ${summary.inputConsistency.overallConsistent ? 'CONSISTENT' : 'INCONSISTENT'}`);\nconsole.log(`⚡ Async: ${summary.asyncComputation.baseValue} × ${summary.asyncUsedInputs.multiplier} = ${summary.asyncComputation.multipliedValue}`);\nconsole.log(`🔗 Dependent: ${summary.derivedValues.doubled} (doubled), ${summary.derivedValues.category} category`);\nconsole.log(`⏱️  Performance: ${summary.performance.totalProcessing}ms total, ${summary.performance.efficiency}`);\nconsole.log(`🔄 Reactivity: ${reactivityTest.chainIntact ? 'WORKING' : 'BROKEN'} - All ${reactivityTest.allStepsCompleted ? '3 steps completed' : 'steps incomplete'}`);\n\n// Test validation with corrected logic\nconst testResults = {\n    inputConsistency: summary.inputConsistency.overallConsistent,\n    asyncReactivityWorking: reactivityTest.asyncTriggered && reactivityTest.dependentTriggered,\n    chainOrderCorrect: dependentCalculations.completedAt > asyncResult.asyncEndTime,\n    noRaceConditions: dependentCalculations.asyncToDependent < 100, // Should be very fast after async completes\n    performanceAcceptable: summary.performance.totalProcessing < (asyncResult.requestedDelay + 500), // Within expected bounds\n    \n    // Overall test result\n    overallResult: 'PENDING'\n};\n\ntestResults.overallResult = \n    testResults.inputConsistency &&\n    testResults.asyncReactivityWorking && \n    testResults.chainOrderCorrect && \n    testResults.noRaceConditions && \n    testResults.performanceAcceptable ? 'PASS' : 'FAIL';\n\nconsole.log(`\\n🧪 === TEST RESULTS ===`);\nconsole.log(`Input Consistency: ${testResults.inputConsistency ? '✅ PASS' : '❌ FAIL'} - Async used current slider values`);\nconsole.log(`Async Reactivity: ${testResults.asyncReactivityWorking ? '✅ PASS' : '❌ FAIL'} - Chain triggered properly`);\nconsole.log(`Chain Order: ${testResults.chainOrderCorrect ? '✅ PASS' : '❌ FAIL'} - Execution order correct`);\nconsole.log(`No Race Conditions: ${testResults.noRaceConditions ? '✅ PASS' : '❌ FAIL'} - Fast chain completion (${dependentCalculations.asyncToDependent}ms)`);\nconsole.log(`Performance: ${testResults.performanceAcceptable ? '✅ PASS' : '❌ FAIL'} - Total time acceptable (${summary.performance.totalProcessing}ms)`);\nconsole.log(`\\n🏆 OVERALL RESULT: ${testResults.overallResult}`);\n\n// Export final results\nexports.summary = summary;\nexports.testResults = testResults;\nexports.reactivityTest = reactivityTest;\nexports.testCompleted = Date.now();\n\n// Create HTML output for visualization\nconst htmlOutput = `\n<div style=\"\n    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);\n    color: white;\n    padding: 20px;\n    border-radius: 10px;\n    font-family: 'Monaco', 'Menlo', monospace;\n    margin: 10px 0;\n    box-shadow: 0 4px 15px rgba(0,0,0,0.3);\n\">\n    <h3>🧪 Async Reactivity Test Results</h3>\n    <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0;\">\n        <div style=\"background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px;\">\n            <strong>📥 Current Inputs</strong><br>\n            Delay: ${summary.currentInputs.asyncDelay}ms<br>\n            Multiplier: ${summary.currentInputs.multiplier}x\n        </div>\n        <div style=\"background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px;\">\n            <strong>🔍 Async Used Inputs</strong><br>\n            Delay: ${summary.asyncUsedInputs.asyncDelay}ms<br>\n            Multiplier: ${summary.asyncUsedInputs.multiplier}x<br>\n            <span style=\"color: ${summary.inputConsistency.overallConsistent ? '#90EE90' : '#FFB6C1'};\">Consistency: ${summary.inputConsistency.overallConsistent ? 'MATCH' : 'MISMATCH'}</span>\n        </div>\n        <div style=\"background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px;\">\n            <strong>⚡ Async Result</strong><br>\n            ${summary.asyncComputation.baseValue} × ${summary.asyncUsedInputs.multiplier} = ${summary.asyncComputation.multipliedValue}<br>\n            Processing: ${summary.performance.asyncDelay}ms\n        </div>\n        <div style=\"background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px;\">\n            <strong>🔗 Dependent Values</strong><br>\n            Doubled: ${summary.derivedValues.doubled}<br>\n            Category: ${summary.derivedValues.category}<br>\n            Chain delay: ${summary.performance.asyncToDependent}ms\n        </div>\n    </div>\n    <div style=\"\n        background: ${testResults.overallResult === 'PASS' ? 'rgba(40, 167, 69, 0.3)' : 'rgba(220, 53, 69, 0.3)'};\n        padding: 15px;\n        border-radius: 5px;\n        text-align: center;\n        font-size: 18px;\n        font-weight: bold;\n    \">\n        ${testResults.overallResult === 'PASS' ? '✅' : '❌'} ASYNC REACTIVITY: ${testResults.overallResult}\n    </div>\n    <div style=\"margin-top: 10px; font-size: 12px; opacity: 0.8;\">\n        Input Consistency: ${testResults.inputConsistency ? '✅' : '❌'} | \n        Chain Order: ${testResults.chainOrderCorrect ? '✅' : '❌'} | \n        No Race Conditions: ${testResults.noRaceConditions ? '✅' : '❌'} | \n        Performance: ${testResults.performanceAcceptable ? '✅' : '❌'}\n    </div>\n</div>\n`;\n\noutput(htmlOutput);"
    },
    {
      "id": "md_02",
      "type": "markdown",
      "content": "## Test Instructions\n\n### How to Test Async Reactivity\n\n1. **Load the notebook** - All cells should execute initially\n2. **Adjust the \"Async Delay\" slider** - Watch for:\n   - 🔄 Code cell 1 re-executes with new delay\n   - ⏳ Async operation takes the specified time\n   - 🔗 Code cell 2 automatically re-executes when async completes\n   - 📊 Code cell 3 updates with new summary\n\n3. **Adjust the \"Multiplier\" slider** - Watch for:\n   - 🔄 Same reactive chain as above\n   - 📈 Different calculation results\n   - ✅ All dependent values update correctly\n\n4. **Try rapid changes** - Test edge cases:\n   - Move sliders quickly back and forth\n   - Check that final results match last slider positions\n   - Verify no intermediate states are lost\n\n### What Should Happen ✅\n\n- **Immediate Trigger**: Slider changes immediately trigger async code\n- **Async Execution**: Code waits for specified delay (simulating real async work)\n- **Chain Reaction**: When async completes, dependent cells automatically re-execute\n- **Correct Order**: Dependent cells always use the latest async results\n- **No Race Conditions**: Fast slider changes don't cause inconsistent states\n- **Error Recovery**: System handles errors gracefully\n\n### What Would Indicate Problems ❌\n\n- **No Reactivity**: Slider changes don't trigger re-execution\n- **Broken Chain**: Async cell executes but dependent cells don't update\n- **Race Conditions**: Dependent cells use stale async results\n- **Lost Updates**: Rapid slider changes result in missed calculations\n- **Incorrect Order**: Cells execute in wrong sequence\n- **Hanging**: Async operations never complete or trigger dependents\n\n### Success Criteria 🎯\n\n1. **Slider → Async**: Input changes trigger async code re-execution\n2. **Async → Dependent**: Async completion triggers dependent code\n3. **Dependent → Display**: Dependent completion triggers final display\n4. **Timing**: All operations complete in expected timeframe\n5. **Consistency**: Final results always match current slider values\n6. **Performance**: No memory leaks or performance degradation\n\n**Current Test Status**: {{testResults?.overallResult || 'Run cells to see results'}}\n\n---\n\n*This test validates that NotebookJS properly handles reactive dependencies with async/await operations, ensuring that modern JavaScript data science workflows maintain correct execution order and state consistency.*"
    }
  ]
}
