{
  "cells": [
    {
      "type": "markdown",
      "id": "md_intro",
      "content": "# Manual Fix Test\n\nThis notebook tests the manual NODE_PATH fix that worked in the console.\n\n## Current State"
    },
    {
      "type": "code",
      "id": "code_current_state",
      "code": "// Check current state before applying fix\noutput('Current require.paths:', require.paths);\noutput('Current NODE_PATH:', process.env.NODE_PATH || 'NOT SET');\noutput('Current Module.globalPaths:', require('module').globalPaths);\n\n// Test if lodash works before fix\ntry {\n    const _ = require('lodash');\n    output('✅ lodash already works (before fix)');\n} catch (error) {\n    output('❌ lodash does not work yet:', error.message);\n}\n\nexports.beforeFix = {\n    requirePaths: require.paths,\n    nodePath: process.env.NODE_PATH,\n    globalPaths: require('module').globalPaths\n};"
    },
    {
      "type": "markdown",
      "id": "md_apply_fix",
      "content": "## Apply Manual Fix\n\nApplying the exact fix that worked in the console."
    },
    {
      "type": "code",
      "id": "code_apply_fix",
      "code": "// Apply the manual fix\noutput('Applying manual fix...');\n\nif (require.paths && require.paths.length > 0) {\n    // Set NODE_PATH from require.paths\n    process.env.NODE_PATH = require.paths.join(\":\");\n    \n    // Reinitialize module paths\n    require(\"module\").Module._initPaths();\n    \n    output('✅ Manual fix applied');\n    output('New NODE_PATH:', process.env.NODE_PATH);\n    output('New Module.globalPaths:', require('module').globalPaths);\n    \n    exports.fixApplied = true;\n    exports.newNodePath = process.env.NODE_PATH;\n    \n} else {\n    output('❌ Cannot apply fix: require.paths is empty');\n    exports.fixApplied = false;\n}"
    },
    {
      "type": "markdown",
      "id": "md_test_after_fix",
      "content": "## Test After Fix\n\nTesting module loading after applying the manual fix."
    },
    {
      "type": "code",
      "id": "code_test_after_fix",
      "code": "// Test modules after applying fix\nconst testModules = ['lodash', 'axios', 'moment', 'uuid'];\nconst results = {};\n\nfor (const moduleName of testModules) {\n    try {\n        const module = require(moduleName);\n        results[moduleName] = 'success';\n        output(`✅ ${moduleName} loaded successfully`);\n        \n        // Show some basic info about the module\n        const version = module.version || module.VERSION;\n        if (version) {\n            output(`   Version: ${version}`);\n        }\n        \n    } catch (error) {\n        results[moduleName] = error.message;\n        output(`❌ ${moduleName} failed: ${error.message}`);\n    }\n}\n\noutput('\\nTest Results Summary:');\noutput(results);\n\nexports.testResults = results;"
    },
    {
      "type": "markdown",
      "id": "md_verify_persistence",
      "content": "## Verify Persistence\n\nChecking if the fix persists across different execution contexts."
    },
    {
      "type": "code",
      "id": "code_verify_persistence",
      "code": "// Check if NODE_PATH persists\noutput('Checking NODE_PATH persistence...');\n\nsetTimeout(() => {\n    output('NODE_PATH after timeout:', process.env.NODE_PATH || 'LOST');\n    \n    // Try loading a module again\n    try {\n        const _ = require('lodash');\n        output('✅ lodash still works after timeout');\n    } catch (error) {\n        output('❌ lodash stopped working after timeout:', error.message);\n    }\n    \n    exports.persistenceTest = {\n        nodePathAfterTimeout: process.env.NODE_PATH,\n        lodashStillWorks: true\n    };\n    \n}, 500);\n\noutput('Persistence test initiated...');"
    }
  ]
}
