{
  "cells": [
    {
      "id": "md_01",
      "type": "markdown",
      "content": "# Async/Await Code Cell Test\n\nThis notebook tests async/await functionality in code cells with modern JavaScript features."
    },
    {
      "id": "code_01",
      "type": "code",
      "code": "// Test 1: Simple async function with setTimeout\nasync function delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nconsole.log('Starting async test...');\nconst startTime = Date.now();\n\n// Use await in code cell\nawait delay(100); // Wait 100ms\n\nconst endTime = Date.now();\nconst elapsed = endTime - startTime;\n\nconsole.log(`Async delay completed in ${elapsed}ms`);\n\n// Export the result\nexports.asyncTestResult = {\n    elapsed,\n    success: elapsed >= 100\n};"
    },
    {
      "id": "code_02", 
      "type": "code",
      "code": "// Test 2: Fetch simulation with async/await\nasync function simulateFetch(url) {\n    console.log(`Simulating fetch to: ${url}`);\n    await delay(50); // Simulate network delay\n    return {\n        url,\n        status: 200,\n        data: { message: 'Success', timestamp: Date.now() }\n    };\n}\n\n// Multiple await calls\nconst response1 = await simulateFetch('https://api.example.com/data1');\nconst response2 = await simulateFetch('https://api.example.com/data2');\n\nconsole.log('Fetch results:', { response1, response2 });\n\n// Export combined results\nexports.fetchResults = {\n    responses: [response1, response2],\n    totalTime: response2.data.timestamp - response1.data.timestamp\n};"
    },
    {
      "id": "code_03",
      "type": "code", 
      "code": "// Test 3: Access results from previous async cells\nconsole.log('Previous async test result:', asyncTestResult);\nconsole.log('Previous fetch results:', fetchResults);\n\n// Verify that async exports are available\nconst verification = {\n    asyncTestPassed: asyncTestResult?.success === true,\n    fetchTestPassed: fetchResults?.responses?.length === 2,\n    bothTestsPassed: false\n};\n\nverification.bothTestsPassed = verification.asyncTestPassed && verification.fetchTestPassed;\n\nconsole.log('Verification results:', verification);\nexports.finalVerification = verification;"
    },
    {
      "id": "code_04",
      "type": "code",
      "code": "// Test 4: Async error handling\nasync function testErrorHandling() {\n    try {\n        console.log('Testing async error handling...');\n        \n        // This should work\n        await delay(10);\n        console.log('First async operation succeeded');\n        \n        // Simulate an error\n        await new Promise((resolve, reject) => {\n            setTimeout(() => reject(new Error('Simulated async error')), 20);\n        });\n        \n    } catch (error) {\n        console.log('Caught async error:', error.message);\n        return { errorCaught: true, errorMessage: error.message };\n    }\n}\n\nconst errorTest = await testErrorHandling();\nconsole.log('Error handling test result:', errorTest);\n\nexports.errorHandlingResult = errorTest;"
    },
    {
      "id": "md_02",
      "type": "markdown", 
      "content": "## Test Results\n\nIf async/await is working correctly:\n- All delays should complete with appropriate timing\n- Fetch simulations should return data\n- Error handling should catch and report async errors\n- All exported values should be accessible in subsequent cells"
    }
  ]
}
